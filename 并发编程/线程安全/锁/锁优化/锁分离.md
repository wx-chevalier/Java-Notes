# 锁分离

根据实际的操作来选择加上不同的锁也是提升性能的重要方式之一。

## 读写分离锁替代独占锁

ReadWriteLock 使用读写分离锁来替代独占锁，它也是减小锁的粒度的一种方式，上面讲的是对数据结构层面的减小锁持有时间的，这里是根据业务来划分锁的持有，在读多写少的场景使用读写分离锁会大大提高系统的并发性能。

## 重入锁和内部锁

重入锁的使用相较于内部锁更加复杂，重入锁必须手动显示释放锁，内部锁则可以自动释放，重入锁提供了一套提高性能的功能和 Condition 机制，重入锁可以设置锁的等待时间 boolean tryLock(long time)，锁中断 lockInterruptibly() 和快速锁轮询 tryLock() 等可以有效的避免死锁的产生。内部锁则是通过 wait() 和 notfiy() 实现锁的控制。

## 自旋锁

自旋锁是 JVM 为了解决对多线程并发时频繁的挂起和恢复线程的操作问题的锁，当访问共享资源的时候，锁的等待时间可能很短，可能会比线程的挂起和恢复时间还要短，因此在这段时间里做线程的切换时不值得的。自旋锁可以使线程没有取得锁时不被挂起，而去执行一个空的循环，当线程获取了锁就会继续执行代码。

但是自旋锁只适用于线程竞争相对小、锁占用时间短的代码，对于锁竞争激烈的系统中不仅浪费了 CPU 资源，也免不了被挂起。JVM 可以设置自旋锁的开启和等待次数，防止一直执行空循环。
