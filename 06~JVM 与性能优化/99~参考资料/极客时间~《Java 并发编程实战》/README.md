# Java 并发编程实战

并发编程可以总结为三个核⼼问题：分⼯、同步、互斥。所谓分⼯指的是如何⾼效地拆解任务并分配给线程，⽽同步指的是线程之间如何协作，互斥则是保证同⼀时刻只允许⼀个线程访问共享资源。Java SDK 并发包很⼤部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是⼀种分⼯模式，CountDownLatch 就是⼀种典型的同步⽅式，⽽可重⼊锁则是⼀种互斥⼿段。

![](https://ngte-superbed.oss-cn-beijing.aliyuncs.com/uPic/VhIeYqdDiu86.png)

## 分工

所谓分⼯，类似于现实中⼀个组织完成⼀个项⽬，项⽬经理要拆分任务，安排合适的成员去完成。在并发编程领域这⽅⾯的成果还是很丰硕的。Java SDK 并发包⾥的 Executor、Fork/Join、Future 本质上都是⼀种分⼯⽅法。除此之外，并发编程领域还总结了⼀些设计模式，基本上都是和分⼯⽅法相关的，例如⽣产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是⽤来指导你如何分⼯的。

学习这部分内容，最佳的⽅式就是和现实世界做对⽐。例如⽣产者 - 消费者模式，可以类⽐⼀下餐馆⾥的⼤厨和服务员，⼤厨就是⽣产者，负责做菜，做完放到出菜⼝，⽽服务员就是消费者，把做好的菜给你端过来。不过，我们经常会发现，出菜⼝有时候⼀下⼦出了好⼏个菜，服务员是可以把这⼀批菜同时端给你的。其实这就是⽣产者 - 消费者模式的⼀个优点，⽣产者⼀个⼀个地⽣产数据，⽽消费者可以批处理，这样就提⾼了性能。

## 同步

在并发编程领域⾥的同步，主要指的就是线程间的协作，本质上和现实⽣活中的协作没区别，不过是⼀个线程执⾏完了⼀个任务，如何通知执⾏后续任务的线程开⼯⽽已。协作⼀般是和分⼯相关的。Java SDK 并发包⾥的 Executor、Fork/Join、Future 本质上都是分⼯⽅法，但同时也能解决线程协作的问题。例如，⽤ Future 可以发起⼀个异步调⽤，当主线程通过 get() ⽅法取结果时，主线程就会等待，当异步执⾏的结果返回时，get() ⽅法就⾃动返回了。主线程和异步线程之间的协作，Future ⼯具类已经帮我们解决了。除此之外，Java SDK ⾥提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是⽤来解决线程协作问题的。

工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。例如，在生产者 - 消费者模型里，也有类似的描述，“当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。“在 Java 并发编程领域，解决协作问题的核心技术是管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，管程是解决并发问题的万能钥匙。”

## 互斥

分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫“线程安全”。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性问题、有序性问题和原子性问题，为了解决这三个问题，Java 语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。

所谓互斥，指的是同一时刻，只允许一个线程访问共享变量。实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题。Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。使用锁除了要注意性能问题外，还需要注意死锁问题。
